# echo回显服务器

一、定义EchoServer class，不需要派生自任何基类

```c

#include<muduo/net/TcpServer.h>

class EchoServer
{
    public:
      EchoServer(muduo::net::EventLoop* loop,const muduo::net::InetAddress& listenAddr);//构造函数
      void start();//calls server_.start();
      
    private:
      void onConnection(const muduo::net::TcpConnectionPtr& conn);//建立连接
      void onMessage(const muduo::net::TcpConnectionPtr& conn,muduo::net::Buffer* buf,muduo::Timeatsmp time);//读消息并回显
      
    muduo::net::EventLoop* loop_;
    muduo::net::TcpServer server_;
};

```

在构造函数里注册回调函数

```c

EchoServer::EchoServer(muduo::net::EventLoop* loop,const muduo::net::InetAddress& listenAddr):loop(loop_),server_(loop,listenAddr,"EchoServer")
{
    server_.setConnectionCallback(boost::bind(&EchoServer::onConnection,this,_1));
    server_.setMessageCallback(boost::bind(&EchoServer::onMessage,this,_1,_2,_3));
}
```

二、实现EchoServer::onConnection,EchoServer::onMessage

```c
void EchoServer::onConnection(const muduo::net::TcpConnectionPtr& conn)//conn为TcpConnection对象的shared_ptr
{
    LOG_INFO<<"EchoServer - "<<conn->peerAddress().toIpPort()<<"->"<<conn->localAddress().toIpPort()<<"is"<<(comm->connected()?"UP":"DOWN");   
}

void EchoServer::onMessage(const muduo::net::TcpConnectionPtr& conn,muduo::net::Buffer* buf,muduo::Timeatsmp time)
{
    muduo::string msg(buf->retrieveAllAsString());
    LOG_INFO<<conn->name()<<" echo "<<msg,size()<<" bytes, "<<"data received at "<<time.toString();
    conn->send(msg);
}
```

三、在main()里用EventLoop让整个程序跑起来

```c
#include"echo.h"
#include<muduo/base/Logging.h>
#include<muduo/net/EventLoop.h>

int main()
{
    LOG_INFO<<"pid="<<getpid();
    muduo::net::EventLoop loop;
    muduo::net::InetAddress listenAddr(2007);
    EchoServer server(&loop,listenAddr);
    server.start();
    loop.loop();
}
```

# 聊天服务器

一、主要功能

- 组成：服务端+客户端

- 协议：

1. 服务端在某个端口监听新的连接

2. 客户端向服务端发起连接

3. 连接建立后，客户端随时准备接收服务端的消息，并在屏幕上显示

4. 客户端接受键盘输入，以回车为界，把消息发送给服务端

5. 服务端收到消息后，将消息发送给每个连接到它的客户端，包括原来发送消息的客户端

6. 一个服务端可以同时服务多个客户端

二、关键问题

- 一个服务器如何处理多个连接

- 如何防止串话：b可能随时断开连接，c用了b的文件描述符，a会不会错误地把消息发送给c

- 分包：在每条消息头部加一个长度字段

    一个间接层：使用编解码器LengthHeaderCodec，将以Buffer* 为参数的MessageCallback转换成以const string& 为参数的StringMessageCallback。

三、服务端

1. 构造函数，在构造函数中注册回调

```c
class ChatServer : boost::noncopyable
{
    public:
        ChatServer(EventLoop* loop,const InetAddress& listenAddr):loop_(loop),server_(loop,listenAddr,"ChatServer"),codec_(boost::bind(&ChatServer::onStringMessage,this,_1,_2,_3))
        {
            server_.setConnectionCallback(boost::bind(&ChatServer::onConnection,this,_1));
            server_.setMessageCallback(boost::bind(&LengthHeaderCodec::onMessage,&coedc_,_1,_2,_3));
            //将LengthHeaderCodec::onMessage()注册给server_ （之前是把本class的onMessage()注册给server_），向codec_注册了ChatServer::onStringMessage
            //相当于让codec_负责解析消息，将完整的消息回调给ChatServer
        }
        void start()//绝对不能在构造函数里调用，会有线程安全问题
        {
            server_.start();
        }
}
```

2. ChatServer类中连接建立和断开

```c

```

四、客户端

- 既要读键盘，又要发消息，而EventLoop是独占线程的，所以用两个线程：

main()所在的线程用于读键盘，EventLoopThread用来处理网络IO


