# echo回显服务器

一、定义EchoServer class，不需要派生自任何基类

```c

#include<muduo/net/TcpServer.h>

class EchoServer
{
    public:
      EchoServer(muduo::net::EventLoop* loop,const muduo::net::InetAddress& listenAddr);//构造函数
      void start();//calls server_.start();
      
    private:
      void onConnection(const muduo::net::TcpConnectionPtr& conn);//建立连接
      void onMessage(const muduo::net::TcpConnectionPtr& conn,muduo::net::Buffer* buf,muduo::Timeatsmp time);//读消息并回显
      
    muduo::net::EventLoop* loop_;
    muduo::net::TcpServer server_;
};

```

在构造函数里注册回调函数

```c

EchoServer::EchoServer(muduo::net::EventLoop* loop,const muduo::net::InetAddress& listenAddr):loop(loop_),server_(loop,listenAddr,"EchoServer")
{
    server_.setConnectionCallback(boost::bind(&EchoServer::onConnection,this,_1));
    server_.setMessageCallback(boost::bind(&EchoServer::onMessage,this,_1,_2,_3));
}
```

二、实现EchoServer::onConnection,EchoServer::onMessage

```c
void EchoServer::onConnection(const muduo::net::TcpConnectionPtr& conn)//conn为TcpConnection对象的shared_ptr
{
    LOG_INFO<<"EchoServer - "<<conn->peerAddress().toIpPort()<<"->"<<conn->localAddress().toIpPort()<<"is"<<(comm->connected()?"UP":"DOWN");   
}

void EchoServer::onMessage(const muduo::net::TcpConnectionPtr& conn,muduo::net::Buffer* buf,muduo::Timeatsmp time)
{
    muduo::string msg(buf->retrieveAllAsString());
    LOG_INFO<<conn->name()<<" echo "<<msg,size()<<" bytes, "<<"data received at "<<time.toString();
    conn->send(msg);
}
```

三、在main()里用EventLoop让整个程序跑起来

```c
#include"echo.h"
#include<muduo/base/Logging.h>
#include<muduo/net/EventLoop.h>

int main()
{
    LOG_INFO<<"pid="<<getpid();
    muduo::net::EventLoop loop;
    muduo::net::InetAddress listenAddr(2007);
    EchoServer server(&loop,listenAddr);
    server.start();
    loop.loop();
}
```

# 聊天服务器

一、主要功能

- 组成：服务端+客户端

- 协议：

1. 服务端在某个端口监听新的连接

2. 客户端向服务端发起连接

3. 连接建立后，客户端随时准备接收服务端的消息，并在屏幕上显示

4. 客户端接受键盘输入，以回车为界，把消息发送给服务端

5. 服务端收到消息后，将消息发送给每个连接到它的客户端，包括原来发送消息的客户端

6. 一个服务端可以同时服务多个客户端

二、关键问题

- 一个服务器如何处理多个连接

- 如何防止串话：b可能随时断开连接，c用了b的文件描述符，a会不会错误地把消息发送给c

- 分包：在每条消息头部加一个长度字段

    一个间接层：使用编解码器LengthHeaderCodec，将以Buffer* 为参数的MessageCallback转换成以const string& 为参数的StringMessageCallback。

三、服务端

1. 构造函数，在构造函数中注册回调

```c
class ChatServer : boost::noncopyable
{
    public:
        ChatServer(EventLoop* loop,const InetAddress& listenAddr):loop_(loop),server_(loop,listenAddr,"ChatServer"),codec_(boost::bind(&ChatServer::onStringMessage,this,_1,_2,_3))
        {
            server_.setConnectionCallback(boost::bind(&ChatServer::onConnection,this,_1));
            server_.setMessageCallback(boost::bind(&LengthHeaderCodec::onMessage,&coedc_,_1,_2,_3));
            //将LengthHeaderCodec::onMessage()注册给server_ （之前是把本class的onMessage()注册给server_），向codec_注册了ChatServer::onStringMessage
            //相当于让codec_负责解析消息，将完整的消息回调给ChatServer
        }
        void start()//绝对不能在构造函数里调用，会有线程安全问题
        {
            server_.start();
        }
}
```

2. ChatServer类中连接建立和断开

```c

```

四、客户端

- 既要读键盘，又要发消息，而EventLoop是独占线程的，所以用两个线程：

main()所在的线程用于读键盘，EventLoopThread用来处理网络IO

## 代码细节

### noncopyable

为了使类具有机密性，制造一个不可被拷贝的类

C++语言编程中，类的拷贝主要是通过拷贝构造函数和赋值函数来进行，再者就是为拷贝专门实现的成员方法。

由于拷贝构造函数和赋值函数在用户为提供的情况下是由C++编译器自动生成的，而且是public成员，因此默认的C++类都有拷贝功能。

一个默认的C++类所拥有的成员函数：

```c
class Empty{}; //空类Empty

Empty();             //默认构造函数
Empty(const Empty &);//默认拷贝构造
~Empty();           //默认析构函数
Empty & operator=(const Empty &)//默认赋值运算符
Empty *operator&();//取地址运算符
const Empty *operator &() const; //取地址运算符const
```
程序员有时候需要给文件加上权限，让这些机密文件不能被随意拷贝，这时候就需要用C++实现不可被拷贝的类。

若让一个C++类不能被拷贝，可显式地声明类的拷贝构造函数和赋值函数为私有函数，从而达到该类不可被拷贝的目的。

主要方法有三种：

一、提供一个基类，任何需要提供不可被拷贝功能的C++类只需从此类派生即可。

```c
class noncopyable
{
    protected:
        noncopyable()=default;//default显式说明要求编译器自动生成默认构造函数
        ~noncopyable()=default;
    private:
        noncopyable(const noncopyable &);
        noncopyable& operator=(const noncopyable &);  
}
```

二、提供一个基类，使用delete关键字

delete关键字加在函数后面，编译器会对指定的函数禁用，从而避免了某些非法的函数调用或者类型转换，从而提高了代码的安全性。

必须在函数第一次声明的时候将其声明为 = delete 函数，否则编译器会报错。

= delete 函数特性可以作用于类的特殊成员函数、类的非特殊成员函数、普通成员函数。

```c
class noncopyable
{
    protected:
        noncopyable()=default;//default显式说明要求编译器自动生成默认构造函数
        ~noncopyable()=default;
    public:
        noncopyable(const noncopyable &)=delete;
        noncopyable& operator=(const noncopyable &)=delete;  
}
```

三、使用boost

```c
#include <boost/utility.hpp>
class A : boost::noncopyable{
public:
    int _a;
    A(int __a) {
        _a = __a;
    }
};
```







