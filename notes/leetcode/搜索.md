<!-- GFM-TOC -->
* [BFS](#bfs)
    * [1091.二进制矩阵中的最短路径（网格中从原点到特定点的最短路径长度）](#1091二进制矩阵中的最短路径网格中从原点到特定点的最短路径长度)
    * [2. 组成整数的最小平方数数量](#2-组成整数的最小平方数数量)
    * [3. 最短单词路径](#3-最短单词路径)
* [DFS](#dfs)
    * [1. 查找最大的连通面积](#1-查找最大的连通面积)
    * [2. 矩阵中的连通分量数目](#2-矩阵中的连通分量数目)
    * [3. 好友关系的连通分量数目](#3-好友关系的连通分量数目)
    * [4. 填充封闭区域](#4-填充封闭区域)
    * [5. 能到达的太平洋和大西洋的区域](#5-能到达的太平洋和大西洋的区域)
* [Backtracking](#backtracking)
    * [1. 数字键盘组合](#1-数字键盘组合)
    * [2. IP 地址划分](#2-ip-地址划分)
    * [3. 在矩阵中寻找字符串](#3-在矩阵中寻找字符串)
    * [4. 输出二叉树中所有从根到叶子的路径](#4-输出二叉树中所有从根到叶子的路径)
    * [5. 排列](#5-排列)
    * [6. 含有相同元素求排列](#6-含有相同元素求排列)
    * [7. 组合](#7-组合)
    * [8. 组合求和](#8-组合求和)
    * [9. 含有相同元素的组合求和](#9-含有相同元素的组合求和)
    * [10. 1-9 数字的组合求和](#10-1-9-数字的组合求和)
    * [11. 子集](#11-子集)
    * [12. 含有相同元素求子集](#12-含有相同元素求子集)
    * [13. 分割字符串使得每个部分都是回文数](#13-分割字符串使得每个部分都是回文数)
    * [14. 数独](#14-数独)
    * [15. N 皇后](#15-n-皇后)
    * [17.电话号码的字母组合](#17电话号码的字母组合)
<!-- GFM-TOC -->

# BFS

广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。

每一层遍历的节点都与根节点距离相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub> <= d<sub>j</sub>。利用这个结论，可以求解最短路径等   **最优解**   问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。

在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。

BFS模板：

```html

void BFS()
{
    定义队列;
    定义备忘录，用于记录已经访问的位置；

    判断边界条件，是否能直接返回结果的。

    将起始位置加入到队列中，同时更新备忘录。

    while (队列不为空) {
        获取当前队列中的元素个数。
        for (元素个数) {
            取出一个位置节点。
            判断是否到达终点位置。
            获取它对应的下一个所有的节点。
            条件判断，过滤掉不符合条件的位置。
            新位置重新加入队列。
        }
    }

}
```

## 1091.二进制矩阵中的最短路径（网格中从原点到特定点的最短路径长度）

[leetcode-1091.二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。可在8个方向移动，返回从左上角到右下角的最短通畅路径长度，不存在，则返回-1。

```c
//bfs求最短路径：第一次遍历到的目的节点，其所经过的路径为最短路径
class Solution
{
   public:
      int dir_x[8]={-1,-1,-1,0,0,1,1,1};
      int dir_y[8]={-1,0,1,-1,1,-1,0,1};
      int shortestPathBinaryMatrix(vector<vector<int>>& grid)
      {
         if(grid.empty() || grid.size() || grid[0].size()) return -1;
         int rows=grid.size(),cols=grid[0].size();
         queue<pair<int,int>> q;
         int route=0;
         q.push({0,0});
         while(!q.empty())
         {
            int sz=q.size();
            route++;
            while(sz-->0)
            {
               auto pos=q.front();
               q.pop();
               int x=pos.first,y=pos.second;
               if(grid[x][y]==1) continue;//只有当前不是1，才能进行下一步，这一句和下一句的位置不能互换
               if(x==rows-1 && y==cols-1) return route;
               grid[x][y]=1;//标记，代替了visited数组
               for(int i=0;i<8;++i)
               {
                  int tx=x+dir_x[i];
                  int ty=y+dir_y[i];
                  if(tx<0 || tx>=rows || ty<0 || ty>=cols) continue;
                  q.push(make_pair(tx,ty));
               }
               
            }
         }
         return -1;
      }
};
```

# Backtracking

## 17.电话号码的字母组合

[leetcode-17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射（与电话按键相同）。注意 1 不对应任何字母。可以任意选择答案输出的顺序。

时间复杂度：O(3^m X 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。

当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 3^m X 4^n 种，需要遍历每一种字母组合。

空间复杂度：O(m+n)，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。

```c
class Solution {
public:
//不是对每个数字代表的字母全排列后再排序
//而是每次从一个数字中选择一个字母，进行排列
    void backtrack(const string& digits,string &s,vector<string>& ans,const unordered_map<char,string>& mp,int index)
    {
        if(index==digits.size())
        {
            ans.push_back(s);
        }
        else
        {
            char c=digits[index];
            const string& ss=mp.at(c);
            //mp[key]如果key不存在会添加key，不会抛出异常；mp.at(key)会检查key，如果不存在会抛出异常。
            for(auto letter:ss)
            {
                s.push_back(letter);
                backtrack(digits,s,ans,mp,index+1);
                s.pop_back();
            }
        }
    }
    vector<string> letterCombinations(string digits) {
        vector<string> ans;
        if(digits.empty()) return ans;
        unordered_map<char,string> mp
        {
            {'2',"abc"},
            {'3',"def"},
            {'4',"ghi"},
            {'5',"jkl"},
            {'6',"mno"},
            {'7',"pqrs"},
            {'8',"tuv"},
            {'9',"wxyz"}
        };
        string s;
        
        backtrack(digits,s,ans,mp,0);
        return ans;
    }
};
```


