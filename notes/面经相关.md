<!-- GFM-TOC -->
* [Linux如何实现杀死进程，kill命令的实质是什么](#linux如何实现杀死进程kill命令的实质是什么)
    * [1. 进程](#1-进程)
    * [2. 线程](#2-线程)
    * [3. 区别](#3-区别)
* [进程间通信](#进程间通信)
* [mmap/fread的区别](#mmapfread的区别)
* [数组和链表的区别](#数组和链表的区别)
* [assert的作用](#assert的作用)

<!-- GFM-TOC -->


# Linux如何实现杀死进程，kill命令的实质是什么


1、kill 命令只是用来向进程发送一个信号，至于这个信号是什么，是用户指定的。


2、kill 命令的执行原理：kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。


3、使用 kill 命令一定可以终止一个进程吗？

不一定。kill 命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。


4、kill -l 看所有信号的列表。共有60个信号可供选择，常用的：SIGTERM(15)和SIGKILL(9)。

SIGTERM：此信号请求一个进程停止运行，可以被忽略。进程可以用一段时间来正常关闭，一个程序的正常关闭一般需要一段时间来保存进度并释放资源。换句话说，它不是强制停止。

SIGKILL：此信号强制进程立刻停止运行。程序不能忽略此信号，而未保存的进度将会丢失。


5、kill命令的使用语法：kill [信号或选项] PID(s) 。默认信号（当没有指定的时候）是SIGTERM。当它不起作用时，可以使用下面的命令来强制kill掉一个进程:

kill SIGKILL PID 或者 kill -9 PID 。这里"-9"代表着SIGKILL信号。

如果不知道应用的PID，仅需要运行这个命令：ps ux ，它会显示所有正在运行的应用还有应用的PID。

# 进程间通信

进程间通信（Inter Process Communication），三个方面：一个进程如何把消息传递给另一个；确保两个或更多进程在关键活动中不会交叉；确保正确的顺序（先产生数据，才能打印）。

三个问题中的后两个对线程同样适用。

# mmap/fread的区别

mmap：[认真分析mmap](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

总结：[mmap和普通文件读写的区别](https://www.cnblogs.com/charlesblc/p/6263665.html)

文件读写：[从内核文件系统看文件读写过程](https://www.cnblogs.com/huxiao-tee/p/4657851.html)

# 数组和链表的区别

[区别](https://blog.csdn.net/Jasminexjf/article/details/88847127)

# assert的作用

ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。

这个宏通常用来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。

例如，变量n在程序中不应该为0，如果为0可能导致错误，可以这样写程序：

```c

ASSERT( n != 0);

k = 10/ n;

```

ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。

assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。

- 程序什么时候应该使用多线程

（1）耗时的操作使用线程，提高应用程序响应

（2）并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。

（3）多CPU系统中，使用线程提高CPU利用率

（4）改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

其他情况都使用单线程。
