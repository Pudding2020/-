# 图

<!-- GFM-TOC -->
* [基本操作](#基本操作)
* [最小生成树](#最小生成树)
* [最短路径](#最短路径)
* [拓扑排序](#拓扑排序)
* [关键路径](#关键路径)
<!-- GFM-TOC -->

## 基本操作

- 构建图

1.邻接矩阵

```html

输入格式：

Nv Ne

v1 v2 w

```

```c

//无向图
int G[MAXN][MAXN],Nv,Ne;//顶点数，边数
void BuildGraph()
{
	int v1,v2,w;
	cin>>Nv;
	for(int i=0;i<Nv;++i)
		for(int j=0;j<Nv;++j)
			G[i][j]=0;//有权图中为INFINITY
	cin>>Ne;
	for(int i=0;i<Ne;++i)
	{
		cin>>v1>>v2>>w;
		G[v1][v2]=G[v2][v1]=w;
	}
}
```

## 最小生成树

- 连通图：图中任意两个顶点都是连通的，则该图是连通图

  连通图的生成树：一个极小的连通子图，包含图中全部的 n 个顶点，只有足以构成一棵树的 n-1 条边
  
  （有n-1条边不一定是生成树）
  
  最小生成树：构造连通网（连通图+权值）的最小代价生成树
  
- Prim（普里姆）算法

设N=（V，{E}）是连通网，TE是N上最小生成树中边的集合。从U={u0}（u0在V中），TE={}开始，重复下述操作：

寻找u0所有边中权值最小的边（u0，v0）；

将（u0，v0）并入TE；

将v0并入U；

直到U=V。

此时，TE中必有n-1条边，T=(V,{TE})为N的最小生成树。

时间复杂度：o(v^2)；适用于稠密图。

- Kruskal（克鲁斯卡尔）算法

设N=（V，{E}）是连通网，令最小生成树初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。

在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上（没有形成回路），则将此边加入到T中；否则舍弃此边，继续选择下一条代价最小的边。

以此类推，直至T中所有顶点都在同一连通分量上为止。

时间复杂度：O(eloge)（e为边数）；由边展开，适用于稀疏图。

## 最短路径

- Dijkstra（迪杰斯特拉）算法

从某个源点到其余各顶点的最短路径。或所有顶点到所有顶点的最短路径问题。

时间复杂度：

有权图的单源最短路径：o(v^2+e)(使用for循环，稠密图效果好)；o(elogv)(使用最小堆，稀疏图效果好)

多源最短路径：稀疏图：o(evlogv)；稠密图：o(v^3+ev)；对稀疏图效果好

- Floyd（弗洛伊德）算法

所有顶点到所有顶点的最短路径问题。

时间复杂度：多源最短路径：o(v^3)；对稠密图效果好

## 拓扑排序

（解决一个工程能否顺利进行）

- AOV网：在一个表示工程的有向图中，顶点表示活动，弧表示活动之间的优先关系，这种有向图为顶点表示活动的网。

  拓扑序列：若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，这种顶点序列为一个拓扑序列。
  
  拓扑排序：对一个有向图构造拓扑序列的过程。
  
  （若此网的全部顶点都被输出，则它是不存在环（回路）的AOV网；若输出顶点数少了，哪怕少一个，则这个网存在环（回路），不是AOV网）
  
- 对AOV网进行拓扑排序的基本思路：

从AOV网中选择一个入度为0的顶点输出，然后删去次顶点，并删除以此顶点为尾的弧，继续重复，直到输出全部顶点或AOV网中不存在入度为0的顶点。

时间复杂度：o(n+e)

## 关键路径

（解决工程完成所需要的最短时间）

- AOE网

在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动持续的时间。只有一个源点（没有入边的顶点）和一个终点（没有出边的顶点）。

（AOV网：顶点表示活动，只描述活动之间的制约关系；AOE网：边表示活动，边上的权值表示活动持续时间）

- 关键路径

路径上各个活动持续时间之和为路径长度；

从起点到终点具有最大长度的路径为关键路径；

在关键路径上的活动为关键活动。





