# 图

<!-- GFM-TOC -->
* [基本操作](#基本操作)
* [图的遍历](#图的遍历)
  * [DFS](#DFS)
  * [BFS](#BFS)
  * [图遍历算法的应用](#图遍历算法的应用)
* [最小生成树](#最小生成树)
* [最短路径](#最短路径)
* [拓扑排序](#拓扑排序)
* [关键路径](#关键路径)
<!-- GFM-TOC -->

## 基本操作

- 构建图

1.邻接矩阵

```html

输入格式：

Nv Ne

v1 v2 w

```

```c

//无向图
int G[MAXN][MAXN],Nv,Ne;//顶点数，边数
void BuildGraph()
{
	int v1,v2,w;
	cin>>Nv;
	for(int i=0;i<Nv;++i)
		for(int j=0;j<Nv;++j)
			G[i][j]=0;//有权图中为INFINITY
	cin>>Ne;
	for(int i=0;i<Ne;++i)
	{
		cin>>v1>>v2>>w;
		G[v1][v2]=G[v2][v1]=w;
	}
}
```

## 图的遍历

### DFS

  深度优先搜索

  从一个顶点出发，访问一个它相连的、未被访问的顶点；再由该顶点出发，访问与它相连的、未被访问的顶点，重复......

  直到没有未被访问的；依次退回到最近访问的顶点，如果有未被访问的，则访问，从它继续重复，直到访问过所有的顶点。
  
  有回退现象，使用递归。
  
### BFS

  广度优先搜索

  从一个顶点出发，访问所有与它相连的、未被访问过的顶点；再依次访问这些访问过的顶点中，未被访问的邻接点，直到访问了全部顶点。
  
  没有回退现象，没有递归。是分层访问，为实现逐层访问，需要一个队列记忆正在访问顶点的下一层顶点。
  
### 图遍历算法的应用

  1.判断图的连通性：能一次访问所有顶点的图是连通图。
  
  2.遍历解答树：
  
    (1)全排列
    
```c      
//求1,2...n的全排列

int n;
void dfs(int num,vector<int> &visited, vector<int> &ans)
{
	if (num >= n)
	{
		for (auto a : ans)
			cout << a;
		cout << endl;
		return;
	}
	for (int i = 1; i <= n; ++i)
	{
		if (!visited[i])
		{
			visited[i] = 1;
			ans[num]=i;
			dfs(num+ 1,visited,ans);
			visited[i] = 0;
		}
	}
}
int main()
{
	cin >> n;
	vector<int> visited(n+1, 0);
	vector<int> ans(n);
	dfs(0,visited,ans);
	system("pause");
	return 0;
}
```
  
    （2）硬币的组合
    
```html

共有1,2,5,10分硬币，不限量，多少种组合，和为Target？

```
    
```c
int target;//目标钱数
int counts;//组合数
int coins[4] = {1,2,5,10};//硬币面值
int val;//记录当前组合为多少钱
void dfs(int num, vector<int> &ans)
{
	if (val == target)
	{
		counts++;
		for (auto a : ans)
			cout << a << " ";
		cout << endl;
		return;
	}
	if (val > target)
		return;
	for (int i = num; i < 4; ++i)
	{
		val += coins[i];
		ans.push_back(coins[i]);
		dfs(i, ans);
		//硬币数量不限，所以递归传入i，而不是i+1；
		//而传入num，则开始值一直是0，会引入重复
		ans.pop_back();
		val -= coins[i];
	}
}
int main()
{
	cin >> target;
	vector<int> ans;
	val = 0;
	counts = 0;
	dfs(0,ans);
	cout << counts;
	system("pause");
	return 0;
}
```
    （3） 1 到 n 个自然数组成的集合的所有组合
    
```c
const int N = 100;//最大可求集合数字为100
int num = 3;//求包含1,2,3的集合
int x[N];//选择要或者不要
void dfs(int depth)//用dfs(0);调用
{
	if (depth >= num)
	{
		bool test = false;//也可以不要这个变量，如果不要，输出第一行有回车，即第一次集合中没有数字也输出了
		for (int i = 0; i < num; ++i)
		{
			if (x[i])//输出要的那一条路
			{
				cout << i + 1;
				test = true;
			}
		}
		if(test) cout << endl;
		return;
	}
	x[depth] = 0;
	dfs(depth + 1);
	x[depth] = 1;
	dfs(depth + 1);
}
 ```
    
    （4）01背包问题
    
    dfs遍历至每个叶子结点，求出小于背包容量的最大值
    
```c
const int N = 100;//物品最大件数
int ans = 0;
int nums;//物品件数
int sizes;//背包重量或容量体积
int weight[N];//物品的重量或容量体积
int value[N];//物品的价值
int x[N];//解向量
void dfs(int depth, int sz, int val)//用dfs(0,0,0);调用
{
	if (depth > nums)//超过解答树深度，该路径不是问题的解
	{
		if (val > ans)
			ans = val;
		return;
	}
	if (sz > sizes)//超过背包容量，该路径不是问题的解
		return;
	if (val > ans)
		ans = val;//保存当前路径解，以便输出最大价值

	//dfs，要或者不要
	dfs(depth+1,sz,val);
	dfs(depth+1,sz+weight[depth],val+value[depth]);
}
```

## 图的基本应用

### 最小生成树

#### 相关概念

  连通图：图中任意两个顶点都是连通的，则该图是连通图

  连通图的生成树：一个极小的连通子图，包含图中全部的 n 个顶点，只有足以构成一棵树的 n-1 条边
  
  （有n-1条边不一定是生成树；生成树少一条边，会成为非连通图；加一条边，会形成回路）
  
  极大连通子图：无向图的连通分量，极大要求该连通子图包含图中所有的边
  
  极小连通子图：连通无向图的生成树，既要保持图连通，又使边数最少
  
  最小生成树：构造连通网（连通图+权值）的最小代价生成树
  
#### Prim（普里姆）算法

  基于**贪心算法**

  设N=（V，{E}）是连通网，TE是N上最小生成树中边的集合。从U={u0}（u0在V中），TE={}开始，重复下述操作：

  寻找u0所有边中权值最小的边（u0，v0）；

  将（u0，v0）并入TE；

  将v0并入U；

  直到U=V。

  此时，TE中必有n-1条边，T=(V,{TE})为N的最小生成树。

  时间复杂度：o(v^2)；适用于稠密图。

- Kruskal（克鲁斯卡尔）算法

  基于**贪心算法**

  设N=（V，{E}）是连通网，令最小生成树初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。

  在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上（没有形成回路），则将此边加入到T中；否则舍弃此边，继续选择下一条代价最小的边。

  以此类推，直至T中所有顶点都在同一连通分量上为止。

  时间复杂度：O(eloge)（e为边数）；由边展开，适用于稀疏图。

## 最短路径

- Dijkstra（迪杰斯特拉）算法

  从某个源点到其余各顶点的最短路径。或所有顶点到所有顶点的最短路径问题。

  时间复杂度：

  有权图的单源最短路径：o(v^2+e)(使用for循环，稠密图效果好)；o(elogv)(使用最小堆，稀疏图效果好)

  多源最短路径：稀疏图：o(evlogv)；稠密图：o(v^3+ev)；对稀疏图效果好

- Floyd（弗洛伊德）算法

  所有顶点到所有顶点的最短路径问题。

  时间复杂度：多源最短路径：o(v^3)；对稠密图效果好

## 拓扑排序

（解决一个工程能否顺利进行）

- AOV网：在一个表示工程的有向图中，顶点表示活动，弧表示活动之间的优先关系，这种有向图为顶点表示活动的网。

  拓扑序列：若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，这种顶点序列为一个拓扑序列。
  
  拓扑排序：对一个有向图构造拓扑序列的过程。
  
  （若此网的全部顶点都被输出，则它是不存在环（回路）的AOV网；若输出顶点数少了，哪怕少一个，则这个网存在环（回路），不是AOV网）
  
- 对AOV网进行拓扑排序的基本思路：

  从AOV网中选择一个入度为0的顶点输出，然后删去次顶点，并删除以此顶点为尾的弧，继续重复，直到输出全部顶点或AOV网中不存在入度为0的顶点。

  时间复杂度：o(n+e)

## 关键路径

（解决工程完成所需要的最短时间）

- AOE网

  在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动持续的时间。只有一个源点（没有入边的顶点）和一个终点（没有出边的顶点）。

  （AOV网：顶点表示活动，只描述活动之间的制约关系；AOE网：边表示活动，边上的权值表示活动持续时间）

- 关键路径

  路径上各个活动持续时间之和为路径长度；

  从起点到终点具有最大长度的路径为关键路径；

  在关键路径上的活动为关键活动。





