# 第一章

- 用户角度上，操作系统是一个控制软件：管理应用程序、为应用程序程序提供服务、杀死应用程序
    
    资源管理：管理外设、分配资源
    
             CPU——进程（CPU虚拟化为进程）  磁盘——文件  内存——地址空间
             
    承上启下作用：硬件之上 应用程序之下
    
    研究kernel（内核），而不是shell（外壳）（如：图形界面、字符命令行）
    
- 操作系统内部组件——Kernel

    1、CPU管理（CPU调度、进线程管理）
    
    2、内存管理（物理内存、虚拟内存）
    
    3、文件系统管理
    
    4、中断处理与设备驱动（需要良好的硬件管理和合理的资源分配）
    
- OS Kernel的特征

    1、并发 计算机系统中同时存在多个运行的程序，需要OS管理和调度
       
       （一个段时间内多个程序运行；并行：在一个时间点上多个程序可以同时运行，要求有多个CPU）
       
    2、共享 互斥共享、“同时”访问
    
    3、虚拟 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务
    
    4、异步
    
       程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知
       
       但只要运行环境相同，OS需保证程序运行的结果也要相同
    
- 操作系统的结构

    1、简单操作系统MS-DOS：1981-1994 汇编语言 不分模块的单体内核
    
    2、Unix：1972年由Kenneth Thompson和Dennid Ritchie在贝尔实验室设计  C语言
    
    3、微内核的设计：尽可能把内核功能移到用户空间
    
    4、一种极端的架构：外核
    
    5、VMM虚拟机监视器：将单独的机器接口转换成很多幻象，每个接口是一个原是计算机的有效副本，并完成所有处理器命令
    
      操作系统之下为VMM，VMM之下为硬件
      
      多操作系统共享硬件资源
      

# 第二章  启动、中断、异常和系统调用

## 启动

一、启动过程

    1、DISK（硬盘）：存放OS    
    
       BIOS（基本I/O处理系统）：让计算机开机后可以检测各种外设  
       
       Bootloader：放在硬盘的第一个主引导扇区 加载OS，让OS从硬盘放入内存，使CPU可以执行OS
       
    2、上电后：
    
       （1）BIOS从特定地址开始执行，进行初始化检查（如：POST（加电自检）、寻找显卡和执行BIOS）
       
            若一切正常，则加载Bootloader，从硬盘放入内存中。
    
            BIOS在内存中占特定地址，以X86为例，地址为CS:IP=0xf000:fff0，CS-段寄存器，IP指令寄存器
           
       （2）Bootloader掌握CPU控制权，将OS从硬盘上加载内存中。    
       
            Boothloader的位置由BIOS设定，占512字节
            
       （3）OS掌握CPU控制权，从OS起始位置开始执行
       
二、操作系统与设备和程序交互（开启后正常工作）

## 系统调用、异常、中断

一、定义

    系统调用（来源于应用程序）：应用程序主动向操作系统发出服务请求；

    异常（来源于不良应用程序）：非法指令或其他坏的处理状态，如：内存出错
    
    中断（来源于外设）：来自不同的硬件设备的计时器和网络的中断
    
二、操作系统存在的意义

    在计算机运行中，内核是被信任的第三方，而应用程序不被信任，不可直接访问外设；
    
    只有内核可以执行特权指令；
    
    为了方便应用程序。
    
三、三者的异同

    1、源头
    
        中断：外设
        
        异常：应用程序意想不到的行为
        
        系统调用：应用程序请求操作提供服务（主动、有意识的，如读取文件，发送文件等）
   
    2、处理时间
   
        中断：异步（不知什么时候会产生）
        
        异常：同步（知道执行这条指令后会产生）
        
        系统调用：异步或同步（发出请求是同步的，执行完成返回时可能为同步也可能为异步）
        
    3、响应
        
        中断：持续，对用户应用程序是透明的（应用程序不知道什么时候产生中断）
        
        异常：杀死或重新执行意想不到的应用程序指令
        
        系统调用：等待和持续
       
四、中断和异常处理机制

![](https://i.bmp.ovh/imgs/2020/04/5ca03bd05d40b7a5.png)

    1、首先，都需要知道异常服务例程发生了哪种中断或异常，由中断向量表获得它们的编号及对应的地址，直接转跳
        
        软硬件都有操作
        
    2、中断
    
        硬件：设置中断标记（CPU初始化）
        
              （1）将内部、外部事件设置中断标记；
              
              （2）中断事件的ID。
              
         软件：保存当前处理状态；中断服务程序处理；清除中断标记；恢复之前保存的处理状态。
         
     3、异常
     
         同样有异常编号
        
         保存现场；异常处理（杀死产生了异常的程序；重新执行异常指令）；恢复现场。
         
五、系统调用

    1、程序访问主要是通过高层次的API接口，而不是直接进行系统调用
    
        -- Win32 API 用于 Windows
        
        -- POSIX（通用、可移植的） API 用于 POSIX-based systems （包括UNIX 、LINUX 、MAC OS X 的所有版本）
        
        -- Java API 用于 JAVA 虚拟机（JVM）
        
    2、特权级转换的变化
    
        用户态：应用程序在执行过程中，CPU所处的特权级状态（特权级很低，不能直接访问某些特殊机械指令和IO）
    
        内核态：操作系统运行时，COU所处的状态，可以完全控制整个计算机系统
        
        应用程序调用系统调用时，完成从用户态到内核态转换，控制权从应用程序交到操作系统。
        
        操作系统对应用程序发出的参数、ID号等作出标识，使其对系统调用进行识别，完成具体服务
         
    3、其他变化
    
        函数调用：在一个栈空间完成参数传递和返回
        
        系统调用：应用程序和OS有各自的堆栈
        
        需完成堆栈的切换  所以开销比函数调用大  但是安全、可靠
        
    4、小结：跨越操作系统边界的开销
    
        （1）执行时间上的开销超过程序调用
        
        （2）开销
        
            -- 建立中断、异常、系统调用号与对应服务，例程映射关系的初始化开销；
            
            -- 建立内核堆栈；
            
            -- 验证参数（不信任应用程序，对其进行检查）；
            
            -- 内核态映射到用户态的地址空间，更新页面映射权限；
            
            -- 内核态独立地址空间（TLB）
            
            这些开销值得 使系统安全稳定地运行
            

# 第三章  操作系统对物理内存的管理（一）

## 计算机体系结构及内存分层体系

一、 计算机体系结构

    1、三部分
    
        -- CPU：完成程序软件的执行和控制
        
        -- 内存：放置程序代码及它所处理的数据
        
        -- 设备：配合程序完成功能
        
二、内存分层体系：CPU所访问的数据、指令在内存中的位置

![](https://i.bmp.ovh/imgs/2020/04/d25aac9ef74d8c18.png)

    寄存器、cache（高速缓存） 位于 CPU 内部，OS无法直接管理；速度快；容量小；
    
    主存/物理内存：放置OS本身要运行的代码；速度慢一些；容量大；掉电丢失数据；
        
    硬盘/虚拟内存：速度慢；容量大；
    
三、OS 在内存管理中需要完成的目标
    
    抽象（逻辑地址空间）、保护（独立地址空间）、共享（访问相同内存）、虚拟化（更多的地址空间，放置暂时不执行的应用程序）
    
四、在 OS 中管理内存的不同方法

    程序重定位；分段；分页；虚拟内存；按需分页虚拟内存
    
五、OS 为一个特殊的软件，实现高度依赖于硬件

    必须知道内存架构；
    
    MMU（内存管理单元）：硬件组件负责处理 CPU 的内存访问请求
    
## 地址空间与地址生成

一、 地址空间

    物理地址空间（PA）：硬件支持的地址空间；与硬件直接对应，如：内存条代表的主存、硬盘；由硬件完成管理和控制；
    
    逻辑地址空间(LA)：一个运行的程序所拥有的内存范围，是一个一维的线性空间；如 C 中变量名、函数名

二、地址生成

    1、 逻辑地址生成：编译-- 汇编-- 链接-- 载入（程序重定位，放入内存中，此时仍为逻辑地址）；会有偏移，偏移量可以为0；
    
                    过程中不需要 OS 参与；

    2、 物理地址：CPU将指令从内存中取出，得到逻辑地址；
    
             CPU中的 MMU 完成逻辑地址到物理地址的映射；
             
             硬件从相应物理内存中取出地址。
             
![](https://i.bmp.ovh/imgs/2020/04/d8965bd3944b9710.png)
             
    3、 物理地址生成的整体流程：
    
        -- CPU
        
            ALU 计算逻辑单元：需要逻辑地址的内存内容，发出请求，发出逻辑地址；
            
            MMU 内存管理单元：进行逻辑地址和物理地址的转换（查找映射表中有无对应的物理地址，没有的话，则去内存中 MAP 找）；
            
            CPU 控制逻辑：给总线发送物理地址请求；
            
        -- 内存
        
            发送物理地址的内容给 CPU ；或接收 CPU 数据到物理地址；
            
        -- 操作系统
        
            （在以上四步之前）建立逻辑地址LA和物理地址PA 的映射；可以放在内存中，由CPU缓存，加快访问过程
    
三、地址安全检查

![](https://i.bmp.ovh/imgs/2020/04/7673b93054adfe7b.png)

## 连续物理内存分配：内存碎片与分区的动态分配

一、内存碎片问题：空闲内存不能被利用

    外部碎片：在分配单元间的未使用内存；
    
    内部碎片：在分配单元中的未使用内存（已经分配给了应用程序，但它未使用）；
    
二、分区的动态分配

    1、简单的内存管理方法
    
        当一个程序准许运行在内存中时，分配一个连续的区间；
        
        分配一个连续的内存空间给运行的程序以访问数据；
        
    2、分配策略
    
        首次适配；最优适配；最差适配；

    3、首次适配（first fit）
    
        简单实现：为了分配 n 字节，使用第一个可用空闲块以致块的尺寸比 n 大；
        
        需求：- 按地址排序的空闲块列表；
        
              - 分配需要寻找一个合适的分区；
              
              - 重分配（若有）需要检查，看是否自由分区能合并于相邻的空闲分区；
              
        优势：- 简单；
        
              - 易于产生更大空闲块，向着地址空间的结尾；
              
        劣势： - 容易产生外部碎片；
        
               - 不确定性；
        
    4、最优适配（best fit）
    
        为了分配 n 字节，使用最小的可用空闲块，以致块的尺寸比 n 大；
        
        需求：- 按尺寸排序的空闲块列表；
        
              - 分配需要寻找一个合适的分区；
              
              - 重分配（若有）需要检查，看是否自由分区能合并于相邻的空闲分区；
              
        优势：- 避免分割大空闲块，当大部分分配是小尺寸时非常有效；
        
              - 最小化外部碎片产生的尺寸；
              
              - 比较简单；
    
        劣势：- 易产生外部碎片；
        
              - 重分配慢；
              
              - 易产生很多没用的微小碎片，不利于后续分配和管理；
              
     5、最差适配（worst fir）
     
        为了分配 n 字节，使用最大可用空闲块，以致块的尺寸比 n 大；
        
        需求：- 按尺寸排序的空闲块列表；
        
              - 分配很快（获得最大的分区）；
              
              - 重分配（若有）需要检查，看是否自由分区能合并于相邻的空闲分区；
              
         优势：避免有太多微小的碎片，分配中等尺寸效果最好；
         
         劣势：- 重分配慢；
         
               - 易产生外部碎片；
               
               - 易于破碎大的空闲块以致大分区无法被分配；
               
    小结：以上为简单管理算法，没有最好和最坏，因为程序需要的内存是随机的，可能大可能小。
     
## 连续物理内存分配：压缩式与交换式碎片整理

    压缩式compress：重置程序，合并空闲块（要求所有程序是动态可重置的）（何时重置？开销如何？）

    交换式swap：运行程序需要更多的内存时，抢占等待的程序，将等待程序copy到磁盘，回收他们的内存


# 第四章 操作系统对物理内存的管理（二）

## 非连续内存分配：分段（Segmentation）

一、使用非连续分配的原因

    1、连续内存分配的缺点：
    
        分配给一个程序的物理内存是连续的；
        
        内存利用率较低；
        
        有外碎片、内碎片的问题；
        
    2、非连续分配的优点：
    
        一个程序的物理地址空间是非连续的；
        
        更好的内存利用和管理；
        
        允许共享代码与数据（共享库等...）；
        
        支持动态加载和动态链接；
        
        缺点：管理开销大
        
        如何建立虚拟地址和物理地址之间的转换？可使用软件方案和硬件方案，软件方案开销可能很大，所以使用硬件
        
        两种硬件方案：分段、分页
        
二、分段 —— 更好地分离和共享

    进程的段地址空间由多个段组成：主代码段、子模块代码段、公用库代码段、堆栈段、堆数据、初始化数据段、符号表等

    将一个连续逻辑地址的应用程序（大的一维字节流，一段）  通过分段技术支持 映射为不连续的物理地址（多段）
        
三、分段寻址方案

    1、段访问机制
    
    - 一个段：一个内存块，一个逻辑地址空间
    
    - 程序访问内存地址需要：一个二维的二元组（s，addr；s —— 段号segnment；addr —— 段内偏移）

    - 有两种实现方式
    
        段寄存器 + 地址寄存器（s，addr分开存放，如x86）；
        
        单地址：（s，addr挨着存放）；
    
    2、段访问的硬件实现
    
![](https://i.bmp.ovh/imgs/2020/04/88b73b95ba7ae46a.png)

    （1）CPU执行应用程序的每条指令，通过段号寻找所在段的起始物理地址，映射关系在段表中储存；
    
            段表：由 OS （在寻址前）建立
            
                  - 存储段的起始地址（逻辑地址段号与物理地址段号的对应关系）；
            
                  - 存储段的长度限制；
                  
                  Index - 段号
                  
     （2）CPU通过段表信息，检查段长度是否满足长度限制，若满足，则合法，将起始地址+偏移量形成物理地址，取出数据交给CPU处理；
     
            若不满足，则为非法机制，CPU对OS产生异常。

    

## 非连续内存分配：分页（Paging）（大部分 CPU 采取的方式）

一、分页地址空间

    同样需要页号和页偏移；但段的大小可变，页帧/页大小不可变
    
    1、划分物理内存至固定大小的帧（frame）：大小是2的幂，eg：512,4096,8192；
    
        划分逻辑地址空间至相同大小的页（page）：大小是2的幂，eg：512,4096,8192
        
    2、建立方案：转换逻辑地址为物理地址（pages to frames）
    
        页表；
        
        MMU/TLB（快表，完成对页表的缓存）；
        
    3、帧：物理内存被分割为大小相等的帧
    
        一个内存物理地址是一个二元组（f，o）  物理地址 = 2^S X f + o
             
        f —— 帧号（F位，共有2^F个帧）  o —— 帧内偏移（S位，每帧有2^S字节）
        
        eg：16-bit的地址空间，9-bit（512 byte）大小的页帧，物理地址=（3,6），物理地址=1542
        
            F=7(16-9) S=9  f=3  o=6  物理地址 = 2^9*3+6 = 1536+6 = 1542
            
     4、页：一个程序的逻辑地址空间被划分为大小相等的页
     
        页内偏移的大小 = 帧内偏移的大小    页号大小 < / > 帧号大小
        
        一个逻辑地址是一个二元组（p,o）  虚拟地址 = 2^S X p + o
        
        p —— 页号（P位，2^P个页）  o —— 页内偏移（S位，每页有2^S字节）

二、页寻址机制 —— 页映射到帧

    1、程序的逻辑地址由很多页组成，每一页大小相同
    
        逻辑地址中的页号是连续的；物理地址中的帧号是不连续的；不是所有的页都有对应的帧
        
        页是连续的虚拟内存；帧是非连续的物理内存；有助于减少碎片
    
    2、实现过程
    
![](https://i.bmp.ovh/imgs/2020/04/258fe46dbe579727.png)
    
        （1）CPU 将页号作为索引，结合页表基址（PTBR - 页表基址寄存器），找到页表的存放位置，查询页表（一个大数组），得到f（帧号）；
        
        （2）f 与 o 得到物理地址
        
        （OS 在之前建立页表）

## 非连续内存分配：页表（Page Table）

一、页表概述

    1、页表结构
    
        - 每个运行的程序都有一个页表，属于程序运行状态，会动态变化
        
        - 页表项组成：（1）帧号f
        
                     （2）页表项标志：存在位（resident bit）；修改位（dirty bit）；引用位（clock/reference bit）
        
            

二、转换后备缓冲区（TLB）

三、二级/多级 页表

四、反向页表

        
    
        



        
        
    
    


    

        

           
           
       

   


