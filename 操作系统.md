# 第一章

- 用户角度上，操作系统是一个控制软件：管理应用程序、为应用程序程序提供服务、杀死应用程序
    
    资源管理：管理外设、分配资源
    
             CPU——进程（CPU虚拟化为进程）  磁盘——文件  内存——地址空间
             
    承上启下作用：硬件之上 应用程序之下
    
    研究kernel（内核），而不是shell（外壳）（如：图形界面、字符命令行）
    
- 操作系统内部组件——Kernel

    1、CPU管理（CPU调度、进线程管理）
    
    2、内存管理（物理内存、虚拟内存）
    
    3、文件系统管理
    
    4、中断处理与设备驱动（需要良好的硬件管理和合理的资源分配）
    
- OS Kernel的特征

    1、并发 计算机系统中同时存在多个运行的程序，需要OS管理和调度
       
       （一个段时间内多个程序运行；并行：在一个时间点上多个程序可以同时运行，要求有多个CPU）
       
    2、共享 互斥共享、“同时”访问
    
    3、虚拟 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务
    
    4、异步
    
       程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知
       
       但只要运行环境相同，OS需保证程序运行的结果也要相同
    
- 操作系统的结构

    1、简单操作系统MS-DOS：1981-1994 汇编语言 不分模块的单体内核
    
    2、Unix：1972年由Kenneth Thompson和Dennid Ritchie在贝尔实验室设计  C语言
    
    3、微内核的设计：尽可能把内核功能移到用户空间
    
    4、一种极端的架构：外核
    
    5、VMM虚拟机监视器：将单独的机器接口转换成很多幻象，每个接口是一个原是计算机的有效副本，并完成所有处理器命令
    
      操作系统之下为VMM，VMM之下为硬件
      
      多操作系统共享硬件资源
      
# 第二章 启动 中断 异常和系统调用

## 启动

一、启动过程

    1、DISK（硬盘）：存放OS    
    
       BIOS（基本I/O处理系统）：让计算机开机后可以检测各种外设  
       
       Bootloader：放在硬盘的第一个主引导扇区 加载OS，让OS从硬盘放入内存，使CPU可以执行OS
       
    2、上电后：
    
       （1）BIOS从特定地址开始执行，进行初始化检查（如：POST（加电自检）、寻找显卡和执行BIOS），若一切正常，则加载Bootloader，从硬盘放
       
            入内存中。
    
            BIOS在内存中占特定地址，以X86为例，地址为CS:IP=0xf000:fff0，CS-段寄存器，IP指令寄存器
           
       （2）Bootloader掌握CPU控制权，将OS从硬盘上加载内存中。    
       
            Boothloader的位置由BIOS设定，占512字节
            
       （3）OS掌握CPU控制权，从OS起始位置开始执行
       
二、操作系统与设备和程序交互（开启后正常工作）

## 系统调用、异常、中断

一、定义

    系统调用（来源于应用程序）：应用程序主动向操作系统发出服务请求；

    异常（来源于不良应用程序）：非法指令或其他坏的处理状态，如：内存出错
    
    中断（来源于外设）：来自不同的硬件设备的计时器和网络的中断
    
二、操作系统存在的意义

    在计算机运行中，内核是被信任的第三方，而应用程序不被信任，不可直接访问外设；
    
    只有内核可以执行特权指令；
    
    为了方便应用程序。
    
三、三者的异同

    1、源头
    
        中断：外设
        
        异常：应用程序意想不到的行为
        
        系统调用：应用程序请求操作提供服务（主动、有意识的，如读取文件，发送文件等）
   
    2、处理时间
   
        中断：异步（不知什么时候会产生）
        
        异常：同步（知道执行这条指令后会产生）
        
        系统调用：异步或同步（发出请求是同步的，执行完成返回时可能为同步也可能为异步）
        
    3、响应
        
        中断：持续，对用户应用程序是透明的（应用程序不知道什么时候产生中断）
        
        异常：杀死或重新执行意想不到的应用程序指令
        
        系统调用：等待和持续
       
四、中断和异常处理机制

![](https://i.bmp.ovh/imgs/2020/04/5ca03bd05d40b7a5.png)

    1、首先，都需要知道异常服务例程发生了哪种中断或异常，由中断向量表获得它们的编号及对应的地址，直接转跳
        
        软硬件都有操作
        
    2、中断
    
        硬件：设置中断标记（CPU初始化）
        
              （1）将内部、外部事件设置中断标记；
              
              （2）中断事件的ID。
              
         软件：保存当前处理状态；中断服务程序处理；清除中断标记；恢复之前保存的处理状态。
         
     3、异常
     
         同样有异常编号
        
         保存现场；异常处理（杀死产生了异常的程序；重新执行异常指令）；恢复现场。
         
五、系统调用

    1、程序访问主要是通过高层次的API接口，而不是直接进行系统调用
    
        -- Win32 API 用于 Windows
        
        -- POSIX（通用、可移植的） API 用于 POSIX-based systems （包括UNIX 、LINUX 、MAC OS X 的所有版本）
        
        -- Java API 用于 JAVA 虚拟机（JVM）
        
    2、特权级转换的变化
    
        用户态：应用程序在执行过程中，CPU所处的特权级状态（特权级很低，不能直接访问某些特殊机械指令和IO）
    
        内核态：操作系统运行时，COU所处的状态，可以完全控制整个计算机系统
        
        应用程序调用系统调用时，完成从用户态到内核态转换，控制权从应用程序交到操作系统。操作系统对应用程序发出的参数、ID号等作出标识，使其对系统
        
        调用进行识别，完成具体服务
    
    3、其他变化
    
        函数调用：在一个栈空间完成参数传递和返回
        
        系统调用：应用程序和OS有各自的堆栈
        
        需完成堆栈的切换  所以开销比函数调用大  但是安全、可靠
        
    4、小结：跨越操作系统边界的开销
    
        （1）执行时间上的开销超过程序调用
        
        （2）开销
        
            -- 建立中断、异常、系统调用号与对应服务，例程映射关系的初始化开销；
            
            -- 建立内核堆栈；
            
            -- 验证参数（不信任应用程序，对其进行检查）；
            
            -- 内核态映射到用户态的地址空间，更新页面映射权限；
            
            -- 内核态独立地址空间（TLB）
            
            这些开销值得 使系统安全稳定地运行
    

        

           
           
       

   


